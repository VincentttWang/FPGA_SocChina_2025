这套方案采用了 **“硬件加速后端 (FPGA) + Python 交互前端 (Jupyter/Widgets)”** 的架构。它不仅适用于频谱分析，也适用于图像处理、神经网络加速、电机控制等任何需要“参数调节 + 结果反馈”的 PYNQ 项目。

-----

# PYNQ-Z2 交互式可视化通用解决方案

## 1\. 核心架构设计

为了保证代码的可维护性和普适性，建议采用类似 **MVC (Model-View-Controller)** 的分层架构：

  * **数据层 (Model - FPGA/Backend):** 负责与 Overlay、DMA 交互，处理核心计算。
  * **视图层 (View - GUI):** 使用 `ipywidgets` 构建控件，使用 `matplotlib` (ipympl) 绘制图表。
  * **控制层 (Controller - Logic):** 连接控件事件与硬件执行函数，负责数据流转。

## 2\. 技术栈清单

在 PYNQ Jupyter 环境中，标准的可视化技术栈如下：

| 组件 | 库/工具 | 用途 |
| :--- | :--- | :--- |
| **交互绘图** | `matplotlib` (配合 `%matplotlib widget`) | 实现动态刷新、缩放、交互的图表。 |
| **控件系统** | `ipywidgets` | 提供滑块、按钮、下拉菜单、文本框等 UI 组件。 |
| **硬件接口** | `pynq` (`Overlay`, `allocate`) | 加载比特流，管理内存缓冲区 (CMA)。 |
| **部署工具** | **Voilà** | **(关键)** 将 Notebook 渲染为无代码的独立网页应用。 |

-----

## 3\. 通用实现步骤

### 步骤一：封装硬件接口 (Hardware Wrapper)

**原则：** GUI 代码不应包含任何底层 DMA 操作。请将 FPGA 操作封装为纯 Python 函数。

  * **输入：** 普通 Python 数据格式 (list, numpy array, int)。
  * **内部：** 处理 `allocate` 内存分配、数据打包、DMA 传输、等待、解包、`freebuffer`。
  * **输出：** 普通 Numpy 数组或处理结果。

**示例代码结构：**

```python
def run_hardware_task(input_data, param_a, param_b):
    # 1. 数据打包 (Driver Layer)
    in_buffer = allocate(...) 
    # 2. 配置 IP 寄存器 (Register Map)
    ip.write(0x10, param_a)
    # 3. 执行加速 (DMA)
    dma.sendchannel.transfer(in_buffer)
    dma.recvchannel.transfer(out_buffer)
    dma.wait()
    # 4. 清理
    result = out_buffer.copy()
    in_buffer.freebuffer()
    return result
```

### 步骤二：构建可视化画布 (Canvas Setup)

**原则：** 初始化一次，更新多次。不要在循环中创建新的 `figure`。

使用 `%matplotlib widget` 魔术命令启用交互模式。根据数据类型选择绘图方式：

  * **一维信号 (波形/频谱):** 使用 `ax.plot()`，并保存返回的 `Line2D` 对象。
  * **二维信号 (图像/热力图):** 使用 `ax.imshow()`，并保存返回的 `AxesImage` 对象。

<!-- end list -->

```python
%matplotlib widget
import matplotlib.pyplot as plt

# 初始化画布
fig, ax = plt.subplots(figsize=(10, 5))
line, = ax.plot([], []) # 创建空线条对象，保留引用
ax.set_title("实时监控")
```

### 步骤三：设计控制面板 (Widget Layout)

**原则：** 使用容器 (`VBox`, `HBox`) 组织布局，使界面整洁。

根据输入参数类型选择控件：

  * **连续数值 (阈值/增益):** `FloatSlider` / `IntSlider`
  * **状态切换 (开关/模式):** `ToggleButton` / `Checkbox` / `Dropdown`
  * **触发执行:** `Button`

<!-- end list -->

```python
import ipywidgets as widgets

# 定义控件
gain_slider = widgets.FloatSlider(description="增益", min=0, max=10)
mode_dropdown = widgets.Dropdown(options=['Mode A', 'Mode B'], description="模式")
run_btn = widgets.Button(description="执行处理", button_style='success')

# 布局容器
ui_panel = widgets.VBox([
    widgets.HBox([gain_slider, mode_dropdown]),
    run_btn
])
```

### 步骤四：实现更新逻辑 (The "Glue")

**原则：** 这是连接 GUI 和 FPGA 的桥梁。

这里有两种常见的更新模式：

#### 模式 A：事件触发 (Triggered)

适用于：图像处理、单次数据分析。用户调整参数后点击按钮更新。

```python
def on_button_click(b):
    # 1. 获取控件值
    g = gain_slider.value
    
    # 2. 调用硬件函数
    result = run_hardware_task(data, g, ...)
    
    # 3. 更新图表数据 (不重画整个图，只更新数据)
    line.set_data(x_axis, result)
    fig.canvas.draw()

run_btn.on_click(on_button_click)
```

#### 模式 B：连续流/实时刷新 (Streaming/Loop)

适用于：示波器、频谱仪、视频流。参考您提供的材料中的“瀑布图”实现。

```python
def live_loop(change):
    while run_btn.value: # 这是一个 ToggleButton
        # 1. 获取数据 (FPGA)
        data = run_hardware_task(...)
        
        # 2. 更新图表
        line.set_data(x, data)
        fig.canvas.draw()
        fig.canvas.flush_events() # 关键：强制刷新前端
        
        # 3. 避免卡死
        time.sleep(0.05)
```

-----

## 4\. 性能优化技巧 (针对 PYNQ-Z2 PS 端)

在 `spectrum_analyzer_gui.ipynb` 中体现了几个关键优化点，推广如下：

1.  **避免全图重绘 (No `plt.cla()`):**

      * 不要在循环中使用 `plt.cla()` 或 `plt.clf()`。这会极大地消耗 PS 端（ARM CPU）的资源并导致闪烁。
      * **正确做法：** 使用 `line.set_data(x, y)` 或 `image.set_data(new_img)`。

2.  **数据降采样 (Downsampling):**

      * 如果 FPGA 返回 100万个点，不要直接传给 matplotlib。浏览器渲染不动。
      * **正确做法：** 在 Python 端进行切片或降采样（如 `plot_data = raw_data[::10]`）后再绘图。

3.  **分离计算与显示:**

      * 不要让 GUI 更新频率等于 FPGA 处理频率。
      * **策略：** FPGA 可以每秒跑 100 次，但 GUI 最好限制在 10-30 FPS (使用 `time.sleep` 控制)，否则浏览器会崩溃。

-----

## 5\. 最终部署：Dashboard 化

这是让您的可视化方案“产品化”的最后一步。

  * **隐藏代码：** 在 JupyterLab 中安装并使用 **Voilà**。
  * **操作：** 点击 Jupyter 界面上的 "Render with Voilà" 按钮。
  * **效果：** 所有的 Python 代码单元格被隐藏，用户只能看到 Markdown 说明、Matplotlib 图表和 ipywidgets 控件。这使得您的 PYNQ 项目看起来像一个专业的嵌入式 Web 控制台。

## 总结

这套方案的通用性在于：**无论 FPGA 内部跑的是 FFT、Sobel 边缘检测还是 FIR 滤波，Python 端的模式永远是：**

> **配置 Widgets -\> 触发 Event -\> 调用 Overlay 函数 -\> 获取 Result -\> 调用 `.set_data()` 更新 Canvas。**