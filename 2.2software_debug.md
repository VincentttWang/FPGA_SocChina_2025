# **以下是PS部分软件优化内容**

**从2.1的步骤中我们学会了在SD卡上加载overlay的静态处理步骤，本文主要是针对使用ps对overlay进行动态规划。**

### 1\. 动态加载和卸载 Overlay (Overlay Management)

 	eg:# 1. 加载第一个 Overlay (图像处理)

 		image\_ol = Overlay("image\_processor.bit")

 		# ... 进行图像处理 ...

 		# 2. 释放第一个 Overlay

 		image\_ol.free()

 		# 3. 加载第二个 Overlay (信号处理)

 		signal\_ol = Overlay("fft\_accelerator.bit")

 		# ... 进行信号处理 ...



### 2.PS 与 PL 运行时的数据和控制交互 (Runtime Interfacing)

#####  	A. 控制和状态交互 (AXI Lite)

 		·方式： 通过 AXI Lite 接口读写 IP 核的控制寄存器和状态寄存器。（寄存器是自己在vitis hls里面就写好的）

 		·用户操作： 在 Python 中，通过访问 IP 核对象（例如 ol.my\_accel）的属性或调用其方法，实现对 PL 硬件的启动、停止和配置。

 			设置参数： 写入配置寄存器（例如设置滤波器的系数）。

 			启动加速器： 写入启动位（Start bit）。

 			查询状态： 读取状态寄存器（例如等待完成位）。

#####  	B. 高速数据交互 (AXI DMA)

 		·方式： 利用 DMA (Direct Memory Access) 引擎，实现 PS 内存与 PL 加速器之间的高速数据传输，无需 CPU 参与。

 		·用户操作：

 			分配共享内存： 使用 pynq.allocate() 在 PS 内存中分配一块可以被 PL 直接访问的内存缓冲区。

 			配置 DMA 传输： 在 Python 中配置 DMA 引擎，指定源地址和目标地址，然后启动传输。PL 端的 IP 核直接从这块共享内存中读取输入数据，并将结果写回。



 	总结：

 		AXI 是您所有 PS/PL 交互的基石。

 		控制 IP 核（Python） → 通过 AXI4-Lite。（python访问ip核设计好的寄存器里面的数据）

 		传输大量数据（DMA） → 通过 AXI4-Full。

 		IP 核之间的数据流 → 通过 AXI4-Stream。（适用于数据密集型处理，如视频流、信号链等，其中一个 IP 核的输出直接连接到下一个 IP 核的输入。）

&nbsp;			!\[axi](image/AXI.png)

### \*（仅做了解）3. 更高层次的交互抽象 (Pynq Libraries)

 	Pynq 库提供了许多抽象层，让用户不必直接操作底层的寄存器和地址，这是 Pynq 开发与传统 Vivado/SDK 开发的最大区别。

#####  	A. MicroBlaze 和 Bare Metal 交互

 		对于一些简单的控制逻辑，可以将 MicroBlaze（一个软核处理器）集成到 PL 中。

 		方式： PS 可以通过通信协议（如共享内存或 AXI FIFO）与 MicroBlaze 上的 \*\*裸机程序（Bare Metal）\*\*进行交互。

 		优势： 允许在 PL 侧实现一些实时性要求很高的小型控制逻辑，减轻 PS 的负担。

#####  	B. IO 模块抽象 (GPIO/PMOD)

 		方式： Pynq 库将板卡的各种物理接口抽象成了 Python 对象。

 		用户操作： 您可以直接使用 pynq.lib.pynq\_gpio 或 pynq.lib.pmod 库来控制外部引脚或连接 Pmod 模块，就像使用 STM32 时的 GPIO 库一样简单，但底层的控制逻辑仍然是通过 PS 驱动 PL 上的 IP 核来实现的。

